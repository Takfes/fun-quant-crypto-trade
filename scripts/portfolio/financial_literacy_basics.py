"""01_Financial_Literacy

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1l3f_BRo3j4-EJOXfnFzLUmUjrnwwPeum

# [Performance Optimization and Risk Management for Trading](https://www.udemy.com/course/performance-optimization-and-risk-management-for-trading/?couponCode=LETSLEARNNOW)

### Prepare Environment
"""

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import scipy.stats as stats
import seaborn as sns
import yfinance

plt.style.use("seaborn")

START = "2023-01-03"
END = "2024-04-30"
tickers = ["BTC-USD", "EURUSD=X", "^DJI", "GC=F", "IS3N.DE", "VWCE.DE", "ALPHA.AT", "MSFT"]

"""### Download Data"""

raw = yfinance.download(tickers, start=START, end=END)
raw.head()

close = raw["Close"]
close

"""### Normalize-100"""

close.iloc[0]

norm = close.div(close.iloc[0]).mul(100)
norm

norm.drop("BTC-USD", axis=1).plot(figsize=(16, 4), fontsize=13, logy=False)
plt.legend(fontsize=10)
plt.show()

"""### Visualize Returns vs Risk"""

returns = close.pct_change()

returns.describe().T

returns.describe().T[["mean", "std"]].sort_values("mean", ascending=False).plot(kind="bar", figsize=(16, 4))

summary = returns.describe().T
summary.plot(kind="scatter", x="std", y="mean", figsize=(16, 4), s=50, fontsize=15)
for i in summary.index:
    plt.annotate(i, xy=(summary.loc[i, "std"] + 0.00005, summary.loc[i, "mean"] + 0.00005), size=10)
plt.xlabel("Risk (std)", fontsize=15)
plt.ylabel("Mean Return", fontsize=15)
plt.title("Mean Variance Analysis", fontsize=15)
plt.show()

"""### Investment Multiple"""

msft = close["MSFT"]

msft[0], msft[-1]

# Investment Multiple
investment_multiple = msft[-1] / msft[0]
investment_multiple

# Pct Change - Alternative 1
investment_multiple - 1

# Pct Change - Alternative 2
(msft[-1] - msft[0]) / msft[0]

investment_multiple * msft[0]

msft / msft[0]

"""### CAGR (Compound Annual Growth Rate)

$$ Annualized Return=(1+Cumulative Return) ^{365/Days Held} - 1 $$
"""

msft.index[0], msft.index[-1]

td = msft.index[-1] - msft.index[0]
td.days

td_years = td.days / 365.25
td_years

# CAGR Alternative 1 - having investment multiple
cagr = investment_multiple ** (1 / td_years) - 1
cagr

# CAGR Alternative 2 - from scratch
cagr_ = (msft[-1] / msft[0]) ** (1 / ((msft.index[-1] - msft.index[0]).days / 365.25)) - 1
cagr_

# CAGR Alternative 2 - daily context
cagr_daily = (msft[-1] / msft[0]) ** (365.25 / ((msft.index[-1] - msft.index[0]).days)) - 1
cagr_daily

# Investment Multiple from CAGR
(cagr_ + 1) ** (td_years)

print(f"starting price : {msft[0]:.2f}")
print(f"ending price : {msft[-1]:.2f}")
print(f"years : {td_years:.2f}")
print("")
print(f"investment multiple : {investment_multiple:.2f}")
print(f"investment multiple : {(msft[-1]/msft[0])=:.2f}")
print("")
print(f"CAGR : {cagr:.2f}")
print(f"CAGR : {(investment_multiple ** (1/td_years) - 1)=:.2f}")
print(f"investment multiple from CAGR : {(cagr_ + 1) ** (td_years)=:.2f}")
print("")
print(f"ending price : {(1+cagr)**(td_years)*msft[0]=:.2f}")

"""### CAGR Function"""


def cagr(s):
    "Assumes series s, comes with DateTime Index"
    return (s[-1] / s[0]) ** (1 / ((s.index[-1] - s.index[0]).days / 365.25)) - 1


cagr(close["MSFT"]), cagr(close["IS3N.DE"]), cagr(close["VWCE.DE"])

close.apply(cagr).sort_values(ascending=False)

"""### Compound Returns"""

# Same as investment multiple
multiple = (returns["MSFT"] + 1).prod()
multiple

"""### Geometric Mean Returns"""

n_returns = returns["MSFT"].count()
n_returns

# Geometric mean return (daily)
geo_mean = multiple ** (1 / n_returns) - 1
geo_mean

(1 + geo_mean) ** (n_returns)

"""### Arithmetic Mean Return"""

# Arithmetic mean is always greater than the Geometric mean
mu = returns["MSFT"].mean()
mu

# Cannot compound the arithmetic mean
(1 + mu) ** (n_returns)

"""### Discrete Compounding"""

PV = 100  # present value
r = 0.08  # annualized return
n = 1  # investment time period
m = 1  # annual compounding

FV = PV * (1 + r / m) ** (n * m)
print(f"Future Value : {FV}")

effective_annual_rate = (FV / PV) ** (1 / n) - 1
effective_annual_rate
print(f"Effective Annual Rate : {effective_annual_rate:.2%}")

PV = 100  # present value
r = 0.08  # annualized return
n = 1  # investment time period
m = 4  # quarterly compounding

FV = PV * (1 + r / m) ** (n * m)
print(f"Future Value : {FV}")

effective_annual_rate = (FV / PV) ** (1 / n) - 1
effective_annual_rate
print(f"Effective Annual Rate : {effective_annual_rate:.2%}")

"""### Continuous Compounding"""

# APPROXIMATION
PV = 100  # present value
r = 0.08  # annualized return
n = 1  # investment time period
m = 1000  # infinite compounding

FV = PV * (1 + r / m) ** (n * m)
print(f"Future Value Approximated : {FV}")

effective_annual_rate = (FV / PV) ** (1 / n) - 1
effective_annual_rate
print(f"Effective Annual Rate : {effective_annual_rate:.6%}")

# EXACT CALCULATION
PV = 100  # present value
r = 0.08  # annualized return
n = 1  # investment time period
m = 1000  # infinite compounding

FV = PV * np.exp(n * r)
print(f"Future Value Approximated : {FV}")

# Alternative 1
effective_annual_rate = (FV / PV) ** (1 / n) - 1
effective_annual_rate
print(f"Effective Annual Rate : {effective_annual_rate:.6%}")

# Alternative 2
effective_annual_rate = np.exp(r) - 1
effective_annual_rate
print(f"Effective Annual Rate : {effective_annual_rate:.6%}")

r = np.log(FV / PV)
r

r = np.log(effective_annual_rate + 1)
r

"""###  Simple vs Log Returns"""

msft_df = msft.rename("Price").to_frame()

msft_df["Lag_1"] = msft.shift()

# ! EXTRA CAREFUL
# pct_change by default will 'pad' NAs, distorting final result
# msft_df['Pct Change'] = msft.pct_change()
# msft_df.dropna(inplace=True)

msft_df["Pct_Change"] = msft.pct_change(fill_method=None)
msft_df["Returns"] = (msft - msft.shift()) / msft.shift()
msft_df["Log_Returns"] = np.log(msft / msft.shift())

msft_df.describe()

# compound simple returns - investment multiple
msft_df.Returns.add(1).prod()

# sum log returns - investment multiple
np.exp(msft_df.Log_Returns.sum())

# investment multiple for each timestamp - based on compounding
msft_df.add(1).Returns.cumprod()

# investment multiple for each timestamp - cumsum log returns
np.exp(msft_df.Log_Returns.cumsum())  # Alternative - 1
msft_df.Log_Returns.cumsum().apply(np.exp)  # Alternative - 2

# CAGR
(msft[-1] / msft[0]) ** (1 / ((msft.index[-1] - msft.index[0]).days / 365.25)) - 1

"""###  Simple vs Log Returns Example"""

df = pd.DataFrame({"Price": [100, 50, 90]})
df

df["SR"] = df.Price.pct_change()
df["LR"] = np.log(df.Price / df.Price.shift())
df

periods = df.SR.count()
periods

# Mean Simple Returns - WRONG
mean_sr = df["SR"].mean()
mean_sr

# Future Value based on Simple Returns - WRONG
100 * (1 + mean_sr) ** periods

# Geometric Mean
geo_mean = (1 + df.SR).prod() ** (1 / periods) - 1
geo_mean

# Future Value w/ compounding - CORRECT
100 * (1 + geo_mean) ** periods

# Mean Log Returns
mean_lr = df["LR"].mean()
mean_lr

# Future Value based on Log Returns - CORRECT
100 * (1 + mean_lr) ** periods

# USE LOG RETURNS INSTEAD OF COMPOUNDING SIMPLE RETURNS
# Log Returns are Additive
sum_lr = df.LR.sum()
sum_lr

# Future Value based on sum of log returns
100 * np.exp(sum_lr)

"""### Normality Assumption"""

msft_returns = returns["MSFT"].dropna()
msft_returns

msft_returns.plot(kind="hist", figsize=(16, 4), bins=100, density=True)

"""Skewness evaluates how much a distribution deviates from symmetry, while Kurtosis gauges the degree of its peakiness or flatness. [link text](https://towardsdatascience.com/skewness-kurtosis-simplified-1338e094fc85)"""

stats.skew(msft_returns.dropna())

stats.kurtosis(msft_returns.dropna(), fisher=True)

"""### Annualized Returns"""

annual_mu = msft_df.Log_Returns.mean() * 252
annual_mu

(msft[-1] / msft[0]) ** (1 / ((msft.index[-1] - msft.index[0]).days / 365.25)) - 1

# something is wrong here?
# cagr_msft = np.exp(annual_mu) - 1
# cagr_msft

# Annual Std - Alternative - 1
annual_std = msft_df.Log_Returns.std() * np.sqrt(252)
annual_std

# Annual Std - Alternative - 2
annual_std = np.sqrt(msft_df.Log_Returns.var() * 252)
annual_std

msft_df

msft[0] * (1 + cagr_msft) ** (td_years)

msft[-1]
